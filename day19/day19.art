; Day 19 Aplenty 

; read the file into two halves
[workflows,parts]: split.by: "\n\n" replace read "sample" {/\r/} ""

; parse workflows as a tree, 
; with complete conditions to ender the child node

split.by: "\n" 'workflows
tree: #[]
loop workflows [e][
    x: split.by: "{" replace e "}" "" 
    
    line: map split.by: "," x\1 [e][split.by: ":" e]
    t: ""
    tree\[x\0]: map.with:'i line 'y 
    [if? i>0 [t: t ++ (replace line\[i-1]\0 
    [{/([xmas])<(\d)/}, {/([xmas])>(\d)/} ]["$1>=$2" "$1=<$2"])++",", t]
    c:"", if? i<> (size line) -1 [c:y\0]
    @[replace t++c {/,$/} "" last y]]
 
    ]

; parse the parts as a dictionary, interesting application of do keyword

parts:
map split.by: "\n" replace parts ["{","=", "}"] ["#[", ":","]"] [e][do e]

; A DFS prototype for part 1 and 2
explore: function [label][
    print ~"I am at |label|..."
    if? label = "A"  [print "reach A" return 1]
    if? label = "R"  [print "reach R" return 0]
    loop tree\[label] [e][
        print ~"explore |last e|"
        explore last e
    ]
    return 0
]

explore_part: function [label, part][
    if? label = "A"  [return true]
    if? label = "R"  [return false]
    loop tree\[label] [e][
        z: all? map chop split.by: "," fold.seed: "" split.by: "," e\0 [a,x][a++"part\\"++x++","] [e][do e]
        if? z [return explore_part e\1 part ]
    ]
]



; solve part 1
u: select parts [part][explore_part "in" part]
part1: fold u [a p][a + sum values p ]
print ~"part 1 is ..... |part1|"

rul: tree\in\1\0
ran: #[x:[1,4000] m:[1,4000] a:[1,4000] s:[1,4000]]

; NEGATIVE NUMBERS??? HOW TO FIX???
compute: function [rule range][
    new_ran: #[]
    loop ran [k,v][new_ran\[k]: new v]
    
    loop split.by: "," rule [r][
        c:r\0
        num: to :integer join match r {/\d/}
        ineq: match r {/=<|>=|<|>/}
        a: #["=<": [1 0] ">=": [0 0] "<": [1 0-1] ">": [0 1]]
        g: a\[ineq\0]
        print g
        print g\0
        print g\1
        if? g\0=1 [
            new_ran\[c]\[g\0]: min @[new_ran\[c]\[g\0] num + g\1]
        ]else[
            new_ran\[c]\[g\0]: max @[new_ran\[c]\[g\0] num + g\1]
        ]
    ]
    return new_ran
]
; print rul
; print ran
; print compute rul ran

explore_ranges: function [label range][
    ; print ~"I am at |label|..."
    print range
    if? label = "A"  [print product map values range [v][v\1 - v\0 + 1] return]
    if? label = "R"  [return 0]
    loop tree\[label] [e][
        ; print ~"explore |e|"
        print e\0
        new_range: compute e\0 range
        ; print new_range
        explore_ranges e\1 new_range
    ]

]
x:2
print explore_ranges "in" ran

webview .width:  300 
        .height: 200
        .title:  "My webview app"
~---
    This is my webpage|x|
    
        This is some content
    
---